<!DOCTYPE html>
<html lang="ja">
<!-- Version: 4.18.0 -->
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>ホロライブカードゲーム管理ツール</title>
  <link rel="stylesheet" href="css/google-drive-sync.css">
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #333;
    }

    .container {
      max-width: 600px;
      width: 90%;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      padding: 40px;
      text-align: center;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    h1 {
      font-size: 2.2em;
      margin: 20px 0;
      background: linear-gradient(45deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      font-weight: bold;
    }

    .subtitle {
      font-size: 1.1em;
      color: #666;
      margin-bottom: 40px;
      line-height: 1.6;
    }

    .menu-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .menu-card {
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      border: 2px solid transparent;
      border-radius: 15px;
      padding: 30px 20px;
      text-decoration: none;
      color: #333;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      position: relative;
      overflow: hidden;
    }

    .menu-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      transition: left 0.5s;
    }

    .menu-card:hover::before {
      left: 100%;
    }

    .menu-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 30px rgba(0, 0, 0, 0.15);
      border-color: #667eea;
    }

    .menu-icon {
      font-size: 3em;
      margin-bottom: 15px;
      display: block;
    }

    .menu-title {
      font-size: 1.4em;
      font-weight: bold;
      margin-bottom: 10px;
      color: #333;
    }

    .menu-description {
      font-size: 0.95em;
      color: #666;
      line-height: 1.5;
    }

    .footer {
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid rgba(0, 0, 0, 0.1);
      color: #888;
      font-size: 0.9em;
    }

    /* モバイル対応 */
    @media (max-width: 768px) {
      .container {
        padding: 30px 20px;
        margin: 20px;
      }

      h1 {
        font-size: 1.8em;
      }

      .subtitle {
        font-size: 1em;
      }

      .menu-grid {
        grid-template-columns: 1fr;
      }

      .menu-card {
        padding: 25px 15px;
      }

      .menu-icon {
        font-size: 2.5em;
      }

      .menu-title {
        font-size: 1.2em;
      }
      
      /* モバイル版のみで画像一括DLボタンを表示 */
      .mobile-only {
        display: inline-block !important;
      }
    }

    /* デスクトップ版では画像一括DLボタンを非表示 */
    @media (min-width: 769px) {
      .mobile-only {
        display: none !important;
      }
    }

    /* ダークモード対応 */
    @media (prefers-color-scheme: dark) {
      body {
        background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
      }

      .container {
        background: rgba(44, 62, 80, 0.95);
        color: #ecf0f1;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .menu-card {
        background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
        color: #ecf0f1;
      }

      .menu-card:hover {
        border-color: #3498db;
      }

      .menu-title {
        color: #ecf0f1;
      }

      .menu-description {
        color: #bdc3c7;
      }

      .subtitle {
        color: #bdc3c7;
      }

      h1 span {
        color: #95a5a6 !important;
      }

      .footer {
        color: #95a5a6;
        border-top-color: rgba(255, 255, 255, 0.1);
      }
    }

    /* 読み取り専用モードトグルスイッチ */
    .toggle-switch input:checked + .toggle-slider {
      background: linear-gradient(45deg, #dc3545, #c82333) !important;
    }

    .toggle-switch .toggle-slider:before {
      content: "";
      position: absolute;
      height: 22px;
      width: 22px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.4s;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .toggle-switch input:checked + .toggle-slider:before {
      transform: translateX(28px);
    }

    /* ダークモード時の読み取り専用モードセクション */
    @media (prefers-color-scheme: dark) {
      .toggle-switch .toggle-slider {
        background-color: #4a5568 !important;
      }

      .toggle-switch input:checked + .toggle-slider {
        background: linear-gradient(45deg, #e53e3e, #c53030) !important;
      }
    }

    /* 更新確認ボタンのスタイル */
    #updateCheckBtn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4);
    }

    #updateCheckBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none !important;
    }

    /* ドライブエクスポートボタンのスタイル */
    #driveExportBtn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(66, 133, 244, 0.4);
    }

    #driveExportBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none !important;
    }

    /* 画像一括DLボタンのスタイル */
    #imageBulkDownloadBtn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 123, 255, 0.4);
    }

    #imageBulkDownloadBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none !important;
    }

    /* モーダルアニメーション */
    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: scale(0.9) translateY(-20px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    /* 他人のストレイジ閲覧エリアのスタイル */
    #viewingOtherStorageSection {
      animation: pulseGlow 2s ease-in-out infinite;
    }

    @keyframes pulseGlow {
      0%, 100% {
        box-shadow: 0 0 10px rgba(255, 87, 34, 0.3);
      }
      50% {
        box-shadow: 0 0 20px rgba(255, 87, 34, 0.5);
      }
    }

    /* ダークモード時の他人のストレイジ関連スタイル */
    @media (prefers-color-scheme: dark) {
      #viewOtherStorageSection {
        background: rgba(44, 62, 80, 0.5) !important;
      }

      #viewOtherStorageSection h3 {
        color: #ecf0f1 !important;
      }

      #viewOtherStorageSection p {
        color: #bdc3c7 !important;
      }

      #viewOtherStorageSection input {
        background: #2c3e50 !important;
        color: #ecf0f1 !important;
        border-color: #34495e !important;
      }

      #viewOtherStorageSection input:focus {
        border-color: #667eea !important;
      }

      #viewOtherStorageSection details > div {
        background: rgba(44, 62, 80, 0.8) !important;
        color: #bdc3c7 !important;
      }

      #viewingOtherStorageSection {
        background: rgba(255, 87, 34, 0.2) !important;
        border-color: #ff7043 !important;
      }
    }

    /* ダークモード時のモーダルスタイル */
    @media (prefers-color-scheme: dark) {
      #imageDownloadModal > div > div {
        background: #34495e !important;
        color: #ecf0f1 !important;
        border: 1px solid #2c3e50 !important;
      }

      #imageDownloadModal h3 {
        color: #ecf0f1 !important;
      }

      #imageDownloadModal > div > div > div:nth-child(2) {
        background: #2c3e50 !important;
        border: 1px solid #34495e !important;
      }

      #imageDownloadModal > div > div > div:nth-child(3) {
        background: #f39c12 !important;
        border: 1px solid #e67e22 !important;
        color: #2c3e50 !important;
      }

      #imageDownloadModal #progressText {
        color: #bdc3c7 !important;
      }

      #imageDownloadModal #downloadProgress {
        background: #2c3e50 !important;
        border: 1px solid #34495e !important;
      }

      /* ドライブエクスポートモーダル ダークモード */
      #driveExportModal > div > div {
        background: #34495e !important;
        color: #ecf0f1 !important;
        border: 1px solid #2c3e50 !important;
      }

      #driveExportModal h3 {
        color: #ecf0f1 !important;
      }

      #driveExportModal > div > div > div:nth-child(2) {
        background: #2c3e50 !important;
        border: 1px solid #34495e !important;
      }

      #driveExportModal ul {
        color: #bdc3c7 !important;
      }

      #driveExportModal p {
        color: #bdc3c7 !important;
      }

      #exportLoginPrompt {
        background: #f39c12 !important;
        border: 1px solid #e67e22 !important;
        color: #2c3e50 !important;
      }

      #exportExistsPrompt {
        background: #27ae60 !important;
        border: 1px solid #2ecc71 !important;
        color: #ecf0f1 !important;
      }

      /* 公開設定チェックボックス */
      #driveExportModal > div > div > div:nth-child(3) {
        background: #2c4a60 !important;
        border: 1px solid #3d6a8a !important;
      }

      #driveExportModal > div > div > div:nth-child(3) span {
        color: #5fa8d3 !important;
      }

      #driveExportModal > div > div > div:nth-child(3) span span {
        color: #a0aab0 !important;
      }

      /* 共有URL表示部分 */
      #exportResult div[style*="background:#e8f4fd"] {
        background: #2c4a60 !important;
        border: 1px solid #3d6a8a !important;
      }

      #shareUrlInput {
        background: #1e3040 !important;
        color: #ecf0f1 !important;
        border: 1px solid #3d6a8a !important;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ホロライブカードゲーム<br>管理ツール
  <span style="font-size: 0.4em; color: #999; display: block; margin-top: 5px; font-weight: normal;" id="versionDisplay">[v4.18.0]</span>
    </h1>

    <div class="menu-grid">
      <div class="menu-card" onclick="safeNavigate('card_list.html')" style="cursor: pointer;">
        <span class="menu-icon">🃏</span>
        <div class="menu-title">カード一覧</div>
        <div class="menu-description">
          全カードの一覧表示・検索・フィルタリング機能。所持状況の管理やCSVでのデータ管理が可能です。
        </div>
      </div>

      <div class="menu-card" onclick="safeNavigate('binder_collection.html')" style="cursor: pointer;">
        <span class="menu-icon">📚</span>
        <div class="menu-title">バインダーコレクション</div>
        <div class="menu-description">
          複数のバインダーを管理。お気に入りの表紙画像を設定して、テーマ別にカードをコレクションできます。
        </div>
      </div>

      <div class="menu-card" onclick="safeNavigate('holoca_skill_page.html')" style="cursor: pointer;">
        <span class="menu-icon">🗂️</span>
        <div class="menu-title">カード詳細検索</div>
        <div class="menu-description">
          詳細な条件でカードを検索。スキル・能力・コストなど様々な条件で絞り込めます。
        </div>
      </div>

      <div class="menu-card" onclick="safeNavigate('deck_builder.html')" style="cursor: pointer;">
        <span class="menu-icon">⚔️</span>
        <div class="menu-title">デッキ作成</div>
        <div class="menu-description">
          戦略的なデッキを構築。カードの組み合わせを考えながら最適なデッキを作成できます。
        </div>
      </div>

      <div class="menu-card" onclick="safeNavigate('battle_simulator.html')" style="cursor: pointer;">
        <span class="menu-icon">🎮</span>
        <div class="menu-title">バトルシミュレーター</div>
        <div class="menu-description">
          作成したデッキでCPUと対戦。ホロライブTCGのルールに従った本格的なバトルが楽しめます。
        </div>
      </div>
    </div>

    <!-- 読み取り専用モード切り替え -->
    <div id="readOnlyModeSection" style="text-align: center; margin: 20px 0; padding: 15px; background: rgba(0,0,0,0.05); border-radius: 10px;">
      <div style="display: flex; align-items: center; justify-content: center; gap: 12px;">
        <span id="readOnlyLabel" style="font-size: 14px; font-weight: bold; color: #666;">🔓 編集可能</span>
        <label class="toggle-switch" style="position: relative; display: inline-block; width: 56px; height: 28px;">
          <input type="checkbox" id="readOnlyToggle" onchange="toggleReadOnlyMode()" style="opacity: 0; width: 0; height: 0;">
          <span class="toggle-slider" style="
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.4s;
            border-radius: 28px;
          "></span>
        </label>
        <span style="font-size: 12px; color: #888;">読み取り専用</span>
      </div>
      <p id="readOnlyDescription" style="margin: 10px 0 0 0; font-size: 12px; color: #888;">
        有効にすると、カード所持数・デッキ・バインダーの編集ができなくなります
      </p>
    </div>

    <!-- 他人のストレイジ閲覧中の戻るボタン -->
    <div id="viewingOtherStorageSection" style="display: none; text-align: center; margin: 20px 0; padding: 15px; background: rgba(255, 87, 34, 0.1); border: 2px solid #ff5722; border-radius: 10px;">
      <div style="display: flex; align-items: center; justify-content: center; gap: 12px; flex-wrap: wrap;">
        <span style="font-size: 14px; font-weight: bold; color: #ff5722;">👁️ 他の人のストレイジを閲覧中</span>
        <button onclick="stopViewingOtherStorage()" style="
          background: linear-gradient(45deg, #ff5722, #f44336);
          color: white;
          border: none;
          padding: 10px 20px;
          border-radius: 20px;
          font-size: 13px;
          font-weight: bold;
          cursor: pointer;
          box-shadow: 0 4px 10px rgba(255, 87, 34, 0.3);
          transition: all 0.3s ease;
        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 15px rgba(255, 87, 34, 0.4)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 10px rgba(255, 87, 34, 0.3)';">
          ✖️ 閲覧を終了して自分のストレイジに戻る
        </button>
      </div>
      <p style="margin: 10px 0 0 0; font-size: 12px; color: #d84315;">
        閲覧モード中は自分のデータには一切影響しません。データの編集はできません。
      </p>
    </div>

    <!-- 他の人のストレイジを見る -->
    <div id="viewOtherStorageSection" style="text-align: center; margin: 20px 0; padding: 15px; background: rgba(0,0,0,0.05); border-radius: 10px;">
      <h3 style="margin: 0 0 15px 0; font-size: 16px; color: #555;">👥 他の人のストレイジを見る</h3>
      <p style="margin: 0 0 10px 0; font-size: 12px; color: #888;">
        共有されたGoogleドライブのファイルIDを入力してください<br>
        <span style="color: #28a745; font-weight: bold;">✓ Googleログイン不要で閲覧できます</span>
      </p>
      <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
        <input
          type="text"
          id="otherStorageFileId"
          placeholder="GoogleドライブのファイルID（例: 1a2b3c...）"
          style="
            width: 100%;
            max-width: 500px;
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
          "
          onfocus="this.style.borderColor='#667eea';"
          onblur="this.style.borderColor='#ddd';"
        />
        <button
          onclick="startViewingOtherStorage()"
          id="startViewingBtn"
          style="
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            transition: all 0.3s ease;
          "
          onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.4)';"
          onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.3)';"
        >
          🚀 開始
        </button>
      </div>
      <details style="margin-top: 15px; text-align: left; max-width: 600px; margin-left: auto; margin-right: auto;">
        <summary style="cursor: pointer; font-size: 13px; color: #667eea; font-weight: bold;">📖 ファイルIDの取得方法</summary>
        <div style="margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.5); border-radius: 5px; font-size: 12px; line-height: 1.6;">
          <ol style="margin: 5px 0; padding-left: 20px;">
            <li>Googleドライブで共有したいバックアップファイル（hololive_card_backup.json）を開く</li>
            <li>右クリックして「共有」→「リンクを取得」を選択</li>
            <li>「リンクを知っている全員」に変更して「リンクをコピー」</li>
            <li>コピーしたURL（https://drive.google.com/file/d/<strong>ファイルID</strong>/view）から<strong>ファイルID</strong>部分を抽出</li>
            <li>上の入力欄にファイルIDを貼り付けて「開始」をクリック</li>
          </ol>
          <p style="margin: 10px 0 0 0; color: #d84315;">
            <strong>⚠️ 注意:</strong> ファイルの共有設定が「リンクを知っている全員」になっていることを確認してください。
          </p>
        </div>
      </details>
    </div>

    <!-- 更新確認・エクスポートボタン -->
    <div style="text-align: center; margin: 20px 0;">
      <button id="updateCheckBtn" onclick="checkForUpdates()" style="
        background: linear-gradient(45deg, #28a745, #20c997);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
        transition: all 0.3s ease;
        margin: 0 10px;
      ">
        🔄 更新確認
      </button>
      <button id="driveExportBtn" onclick="showDriveExportDialog()" style="
        background: linear-gradient(45deg, #4285f4, #34a853);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(66, 133, 244, 0.3);
        transition: all 0.3s ease;
        margin: 0 10px;
      ">
        ☁️ ドライブにエクスポート
      </button>
      <!-- モバイル版のみ画像一括DLボタンを表示 -->
      <button onclick="showImageDownloadDialog()" id="imageBulkDownloadBtn" class="mobile-only" style="
        background: linear-gradient(45deg, #007bff, #0056b3);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(0, 123, 255, 0.3);
        transition: all 0.3s ease;
        margin: 0 10px;
      ">
        📥 画像一括DL
      </button>
      <!-- モバイル版のみキャッシュ削除ボタンを表示 -->
      <button onclick="clearAllCache()" id="clearCacheBtn" class="mobile-only" style="
        background: linear-gradient(45deg, #dc3545, #c82333);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
        transition: all 0.3s ease;
        margin: 0 10px;
      ">
        🗑️ キャッシュ削除
      </button>
      <div id="updateStatus" style="margin-top: 10px; font-size: 12px; color: #666; line-height: 1.3; max-width: 400px; white-space: pre-line;"></div>
    </div>

    <div class="footer">
      <p>© 2025 ikachan-desuyo - Hololive Card Game Management Tool</p>
      <p>このツールは非公式のファンメイドツールです</p>
      <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(0,0,0,0.1); font-size: 0.85em; color: #888; line-height: 1.4;">
        <p><strong>権利表記・免責事項</strong></p>
        <p>「ホロライブ」「hololive」は株式会社カバーの商標です。</p>
        <p>「ホロライブオフィシャルカードゲーム」は株式会社ブシロードの商標です。</p>
        <p>このツールは株式会社カバー・株式会社ブシロードとは無関係の非公式ファンメイドツールです。</p>
        <p>カードデータの著作権は各権利者に帰属します。</p>
        <p>このツールの使用により生じた損害について、作成者は一切の責任を負いません。</p>
      </div>
      <p id="offline-status" style="font-size: 0.8em; margin-top: 10px;"></p>
    </div>
  </div>

  <!-- ドライブエクスポートモーダル -->
  <div id="driveExportModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:2000; backdrop-filter: blur(3px); -webkit-backdrop-filter: blur(3px);">
    <div style="display:flex; align-items:center; justify-content:center; width:100%; height:100%;">
      <div style="background:white; padding:30px; border-radius:10px; max-width:500px; width:90%; text-align:center; box-shadow:0 4px 20px rgba(0,0,0,0.3); animation: modalSlideIn 0.3s ease-out;">
        <h3 style="margin-top:0; color:#333;">☁️ Googleドライブにエクスポート</h3>
        <div style="margin:20px 0; padding:15px; background:#f5f5f5; border-radius:5px; text-align:left;">
          <p style="margin:5px 0;"><strong>エクスポート内容:</strong></p>
          <ul style="margin:10px 0; padding-left:20px; color:#666; font-size:0.95em;">
            <li>カード所持数</li>
            <li>保存したデッキ</li>
            <li>バインダーコレクション</li>
          </ul>
          <p style="margin:10px 0 5px 0; font-size:0.9em; color:#666;">
            <strong>ファイル名:</strong> <span id="exportFileName">hololive_card_backup.json</span>
          </p>
        </div>
        <div style="margin:15px 0; padding:10px; background:#e8f4fd; border:1px solid #b3d7f5; border-radius:5px; text-align:left;">
          <label style="display:flex; align-items:flex-start; cursor:pointer; gap:10px;">
            <input type="checkbox" id="exportPublicCheckbox" style="margin-top:3px; width:18px; height:18px; cursor:pointer;">
            <span style="font-size:0.9em; color:#0066cc;">
              <strong>🔗 誰でも閲覧可能にする</strong><br>
              <span style="color:#666; font-size:0.85em;">リンクを知っている人なら誰でも閲覧できるようになります</span>
            </span>
          </label>
        </div>
        <div id="exportLoginPrompt" style="display:none; margin:15px 0; padding:10px; background:#fff3cd; border:1px solid #ffeaa7; border-radius:5px; font-size:0.9em; color:#856404;">
          <strong>⚠️ Googleログインが必要です</strong><br>
          エクスポートするにはGoogleアカウントにログインしてください。
        </div>
        <div id="exportExistsPrompt" style="display:none; margin:15px 0; padding:10px; background:#d4edda; border:1px solid #c3e6cb; border-radius:5px; font-size:0.9em; color:#155724;">
          <strong>📁 既存ファイルが見つかりました</strong><br>
          <span id="existingFileInfo"></span><br>
          上書きしますか？
        </div>
        <div id="exportProgress" style="display:none; margin:15px 0;">
          <div style="background:#e9ecef; border-radius:10px; height:20px; overflow:hidden;">
            <div id="exportProgressBar" style="background:linear-gradient(90deg, #4285f4 0%, #34a853 100%); height:100%; width:0%; transition:width 0.3s;"></div>
          </div>
          <p id="exportProgressText" style="margin:10px 0; font-size:0.9em; color:#666;">準備中...</p>
        </div>
        <div id="exportResult" style="display:none; margin:15px 0; padding:10px; border-radius:5px; font-size:0.9em;"></div>
        <div style="margin-top:20px;">
          <button onclick="executeExport(false)" id="exportStartBtn" style="background:#4285f4; color:white; border:none; padding:10px 20px; border-radius:5px; cursor:pointer; margin-right:10px; font-size:16px; transition: all 0.3s ease;">☁️ エクスポート</button>
          <button onclick="executeExport(true)" id="exportOverwriteBtn" style="display:none; background:#f4b400; color:white; border:none; padding:10px 20px; border-radius:5px; cursor:pointer; margin-right:10px; font-size:16px; transition: all 0.3s ease;">📝 上書き</button>
          <button onclick="hideDriveExportDialog()" id="exportCancelBtn" style="background:#6c757d; color:white; border:none; padding:10px 20px; border-radius:5px; cursor:pointer; font-size:16px;">キャンセル</button>
        </div>
      </div>
    </div>
  </div>

  <!-- 画像一括ダウンロード確認ダイアログ -->
  <div id="imageDownloadModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:2000; backdrop-filter: blur(3px); -webkit-backdrop-filter: blur(3px);">
    <div style="display:flex; align-items:center; justify-content:center; width:100%; height:100%;">
      <div style="background:white; padding:30px; border-radius:10px; max-width:500px; width:90%; text-align:center; box-shadow:0 4px 20px rgba(0,0,0,0.3); animation: modalSlideIn 0.3s ease-out;">
        <h3 style="margin-top:0; color:#333;">📥 画像一括ダウンロード</h3>
        <div style="margin:20px 0; padding:15px; background:#f5f5f5; border-radius:5px; text-align:left;">
          <p style="margin:5px 0;"><strong>対象画像数:</strong> <span id="totalImageCount">-</span> 枚</p>
          <p style="margin:5px 0;"><strong>推定サイズ:</strong> <span id="estimatedSize">計算中...</span></p>
          <p style="margin:5px 0;"><strong>現在のキャッシュ:</strong> <span id="currentCacheInfo">確認中...</span></p>
          <p style="margin:5px 0; font-size:0.9em; color:#666;">※ 1枚あたり約150-200KBで計算</p>
        </div>
        <div style="margin:15px 0; padding:10px; background:#fff3cd; border:1px solid #ffeaa7; border-radius:5px; font-size:0.9em; color:#856404;">
          <strong>⚠️ 注意事項</strong><br>
          • カード一覧ページのデータを利用して画像をダウンロードします<br>
          • ダウンロードには時間がかかる場合があります<br>
          • モバイルデータ通信の場合、通信量にご注意ください<br>
          • ダウンロード中はページを閉じないでください
        </div>
        <div id="downloadProgress" style="display:none; margin:15px 0;">
          <div style="background:#e9ecef; border-radius:10px; height:20px; overflow:hidden;">
            <div id="progressBar" style="background:linear-gradient(90deg, #007bff 0%, #28a745 100%); height:100%; width:0%; transition:width 0.3s;"></div>
          </div>
          <p id="progressText" style="margin:10px 0; font-size:0.9em; color:#666; white-space:pre-line;">準備中...</p>
        </div>
        <div style="margin-top:20px;">
          <button onclick="startImageDownload()" id="startDownloadBtn" style="background:#007bff; color:white; border:none; padding:10px 20px; border-radius:5px; cursor:pointer; margin-right:10px; font-size:16px; transition: all 0.3s ease;">📥 ダウンロード開始</button>
          <button onclick="clearImageCache()" id="clearCacheBtn" style="background:#dc3545; color:white; border:none; padding:10px 20px; border-radius:5px; cursor:pointer; margin-right:10px; font-size:16px;">🗑️ キャッシュ削除</button>
          <button onclick="hideImageDownloadDialog()" id="cancelDownloadBtn" style="background:#6c757d; color:white; border:none; padding:10px 20px; border-radius:5px; cursor:pointer; font-size:16px;">キャンセル</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ✅ Service Worker との通信機能
    async function sendMessageToSW(type, data = null) {
      if (!navigator.serviceWorker.controller) return null;

      return new Promise((resolve) => {
        const messageChannel = new MessageChannel();
        messageChannel.port1.onmessage = (event) => {
          resolve(event.data);
        };

        navigator.serviceWorker.controller.postMessage(
          { type, data },
          [messageChannel.port2]
        );
      });
    }

    // ✅ バージョン情報を取得
    async function getVersionInfo() {
      return await sendMessageToSW('GET_VERSION_INFO');
    }

    // ✅ 更新メッセージを取得
    async function getUpdateMessage() {
      return await sendMessageToSW('GET_UPDATE_MESSAGE');
    }

    // ✅ 古いページをチェック
    async function checkOutdatedPages() {
      return await sendMessageToSW('CHECK_OUTDATED_PAGES');
    }

    // Service Worker registration with centralized version management
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js', {
          updateViaCache: 'none' // モバイル向け：キャッシュを使わず常に最新をチェック
        })
          .then((registration) => {

            // モバイル向け：即座に更新チェック
            registration.update();

            // ✅ 新しいバージョン管理システムで更新確認
            const checkForUpdates = async () => {
              try {
                // Service Worker が準備できるまで待機
                if (!navigator.serviceWorker.controller) {
                  setTimeout(checkForUpdates, 1000);
                  return;
                }

                const updateMessage = await getUpdateMessage();
                if (!updateMessage) return;

                if (confirm(updateMessage.data.message)) {
                  // 全キャッシュクリア後にリロード
                  const cacheNames = await caches.keys();
                  await Promise.all(cacheNames.map(cacheName => caches.delete(cacheName)));
                  window.location.href = window.location.href + '?v=' + Date.now();
                }
              } catch (error) {
              }
            };

            // Check for waiting service worker with new system
            if (registration.waiting) {
              setTimeout(checkForUpdates, 500);
            }

            // Listen for updates with new system
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              if (newWorker) {
                newWorker.addEventListener('statechange', () => {
                  if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                    setTimeout(checkForUpdates, 500);
                  }
                });
              }
            });

            // Listen for controller change
            navigator.serviceWorker.addEventListener('controllerchange', () => {
              window.location.reload();
            });
          })
          .catch((registrationError) => {
          });
      });
    }

    // モバイル向け：定期的な更新チェック（5分間隔）
    if ('serviceWorker' in navigator && /Mobi|Android/i.test(navigator.userAgent)) {
      setInterval(async () => {
        try {
          const registration = await navigator.serviceWorker.getRegistration();
          if (registration) {
            await registration.update();
          }
        } catch (error) {
        }
      }, 5 * 60 * 1000); // 5分間隔
    }

    // Online/Offline status
    function updateOnlineStatus() {
      const statusElement = document.getElementById('offline-status');
      if (navigator.onLine) {
        statusElement.textContent = '🟢 オンライン - 最新データを取得中';
        statusElement.style.color = '#4CAF50';
      } else {
        statusElement.textContent = '🔴 オフライン - キャッシュデータを使用中';
        statusElement.style.color = '#F44336';
      }
    }

    // Update status on page load and network changes
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
    window.addEventListener('load', updateOnlineStatus);

    // Manual update check function
    let serviceWorkerRegistration = null;

    // Store registration for manual update checks
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
          .then((registration) => {
            serviceWorkerRegistration = registration;
            // ... existing code above
          });
      });
    }

    async function checkForUpdates() {
      const statusEl = document.getElementById('updateStatus');
      const btnEl = document.getElementById('updateCheckBtn');

      if (!navigator.onLine) {
        statusEl.textContent = '⚠️ オフライン状態では更新確認できません';
        statusEl.style.color = '#ff9800';
        return;
      }

      try {
        btnEl.disabled = true;
        btnEl.textContent = '🔄 確認中...';
        statusEl.textContent = 'バージョン情報を確認中...';
        statusEl.style.color = '#2196f3';

        if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
          const messageChannel = new MessageChannel();

          // タイムアウト設定（10秒）
          const timeout = new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Service Worker timeout')), 10000)
          );

          // Service Workerからのレスポンスを待機
          const checkPromise = new Promise((resolve, reject) => {
            messageChannel.port1.onmessage = (event) => {
              if (event.data.type === 'VERSION_MISMATCH_RESPONSE') {
                resolve(event.data.data);
              } else if (event.data.type === 'VERSION_MISMATCH_ERROR') {
                reject(new Error(event.data.error));
              }
            };
          });

          // 詳細バージョンチェック要求を送信
          navigator.serviceWorker.controller.postMessage(
            { type: 'CHECK_VERSION_MISMATCH' },
            [messageChannel.port2]
          );

          // レスポンス待機（タイムアウト付き）
          const versionCheckResult = await Promise.race([checkPromise, timeout]);

          if (versionCheckResult.hasUpdates) {
            // バージョン不一致の詳細情報を生成
            let detailMessage = '🚀 バージョンの不一致が検出されました:\n\n';
            detailMessage += `📊 アプリバージョン: v${versionCheckResult.currentAppVersion}\n`;
            detailMessage += `🕐 チェック時刻: ${new Date(versionCheckResult.timestamp).toLocaleString('ja-JP')}\n\n`;

            versionCheckResult.outdatedPages.forEach(pageInfo => {
              detailMessage += `📄 ${pageInfo.page}:\n`;
              detailMessage += `  ┣ 期待バージョン: v${pageInfo.expectedVersion}\n`;
              detailMessage += `  ┣ 実際のバージョン: v${pageInfo.actualVersion || '不明'}\n`;
              detailMessage += `  ┣ キャッシュバージョン: v${pageInfo.cachedVersion || 'なし'}\n`;

              // ミスマッチの理由を日本語で説明
              let reasonText = '';
              switch(pageInfo.reason) {
                case 'expected_vs_actual_mismatch':
                  reasonText = '期待バージョンと実際バージョンが不一致';
                  break;
                case 'actual_vs_cached_mismatch':
                  reasonText = '実際バージョンとキャッシュバージョンが不一致';
                  break;
                case 'actual_version_not_found':
                  reasonText = '実際のバージョン情報が見つかりません';
                  break;
                case 'no_cached_version':
                  reasonText = 'キャッシュにバージョン情報がありません';
                  break;
                default:
                  reasonText = pageInfo.reason;
              }
              detailMessage += `  ┗ 理由: ${reasonText}\n\n`;
            });

            statusEl.innerHTML = `🚀 更新が利用可能です (${versionCheckResult.outdatedPages.length}ページ)<br><small>詳細情報を確認してください</small>`;
            statusEl.style.color = '#4caf50';

            setTimeout(() => {
              if (confirm(detailMessage + 'バージョン不一致のページを更新してアプリケーションを再読み込みしますか？')) {
                statusEl.innerHTML = `⚡ 更新中...<br><small>対象ページのキャッシュをクリア中</small>`;
                statusEl.style.color = '#ff9800';

                // バージョン不一致のページのみをターゲットにした更新処理

                // Service Workerに強制更新を要求（対象ページのみ）
                if (navigator.serviceWorker.controller) {
                  navigator.serviceWorker.controller.postMessage({
                    type: 'FORCE_UPDATE',
                    outdatedPages: versionCheckResult.outdatedPages.map(p => p.page)
                  });
                }

                // 対象ページのキャッシュクリア + 必要最小限の全体キャッシュクリア
                if ('caches' in window) {
                  caches.keys().then(cacheNames => {
                    return Promise.all(cacheNames.map(cacheName => {
                      return caches.delete(cacheName);
                    }));
                  }).then(() => {
                    statusEl.innerHTML = `🔄 アプリケーションを再読み込み中...<br><small>更新されたページを反映します</small>`;
                    // Service Workerの更新を待つ
                    return new Promise(resolve => setTimeout(resolve, 1000));
                  }).then(() => {
                    // 対象ページの更新を反映するためのリロード
                    if (window.location.reload) {
                      window.location.reload(true); // 強制リロード
                    } else {
                      window.location.href = window.location.href + '?t=' + Date.now();
                    }
                  }).catch(error => {
                    window.location.href = window.location.href + '?t=' + Date.now();
                  });
                } else {
                  // キャッシュAPIが使えない場合のフォールバック
                  window.location.href = window.location.href + '?t=' + Date.now();
                }
              } else {
                // キャンセル時は元の状態に戻す
                statusEl.innerHTML = `ℹ️ 更新がキャンセルされました<br><small>必要な時に再度確認してください</small>`;
                statusEl.style.color = '#2196f3';
              }
            }, 2000);
          } else {
            // 最新の場合、比較したバージョン情報を詳細表示
            let versionDetails = `✅ 最新バージョン v${versionCheckResult.currentAppVersion}<br>`;
            versionDetails += `<small>📊 各ページのバージョン情報:<br><br>`;

            if (versionCheckResult.allPages && versionCheckResult.allPages.length > 0) {
              versionCheckResult.allPages.forEach(pageInfo => {
                const pageName = pageInfo.page.replace('.html', '');
                const expectedV = pageInfo.expectedVersion;
                const actualV = pageInfo.actualVersion;
                const status = expectedV === actualV ? '✅' : '⚠️';

                versionDetails += `${status} ${pageName}<br>`;
                versionDetails += `&nbsp;&nbsp;├ 最新: v${expectedV}<br>`;
                versionDetails += `&nbsp;&nbsp;└ 現在: v${actualV}<br><br>`;
              });
            } else {
              versionDetails += `全ページのバージョンが最新です`;
            }
            versionDetails += `</small>`;

            statusEl.innerHTML = versionDetails;
            statusEl.style.color = '#4caf50';
            setTimeout(() => {
              statusEl.textContent = '';
            }, 7000); // 表示時間を延長
          }
        } else {
          statusEl.textContent = '⚠️ Service Worker が利用できません';
          statusEl.style.color = '#ff9800';
        }

      } catch (error) {
        statusEl.textContent = '❌ 更新確認に失敗しました: ' + error.message;
        statusEl.style.color = '#f44336';
      } finally {
        btnEl.disabled = false;
        btnEl.textContent = '🔄 更新確認';
      }
    }

    // セーフナビゲーション関数（フォールバック付き）
    function safeNavigate(url) {
      
      // offline-utils.js が読み込まれているかチェック
      if (typeof window.navigateToPage === 'function') {
        window.navigateToPage(url);
      } else {
        // フォールバック: 通常のナビゲーション
        if (navigator.onLine) {
          window.location.href = url;
        } else {
          // オフライン時の簡易チェック
          if (confirm('オフライン状態です。このページが利用できない可能性があります。\n移動しますか？')) {
            window.location.href = url;
          }
        }
      }
    }

    // 画像ダウンロード確認ダイアログを表示
    async function showImageDownloadDialog() {
      
      // モバイル版のみ表示（より厳密な判定）
      const isMobile = window.innerWidth <= 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      
      if (!isMobile) {
        alert('画像一括ダウンロードはモバイル版でのみ利用可能です。');
        return;
      }
      
      if (imageDownloadInProgress) {
        alert('画像ダウンロードが実行中です。しばらくお待ちください。');
        return;
      }

      
      // カードデータを読み込み
      if (cards.length === 0) {
        const loadedCards = await loadCardData();
        if (loadedCards.length === 0) {
          return; // データ読み込み失敗
        }
      }

      const modal = document.getElementById('imageDownloadModal');
      const totalImageCountEl = document.getElementById('totalImageCount');
      const estimatedSizeEl = document.getElementById('estimatedSize');
      const currentCacheInfoEl = document.getElementById('currentCacheInfo');
      const startBtn = document.getElementById('startDownloadBtn');
      
      // 画像数を計算
      const imageUrls = extractImageUrls();
      const totalCount = imageUrls.length;
      
      
      if (totalCount === 0) {
        alert('ダウンロード対象の画像が見つかりませんでした。カードデータの読み込みを確認してください。');
        return;
      }
      
      // 推定サイズを計算（1枚あたり150-200KBで計算）
      const avgSizeKB = 175; // 平均サイズ
      const estimatedSizeMB = Math.round((totalCount * avgSizeKB) / 1024 * 10) / 10;
      
      totalImageCountEl.textContent = totalCount.toLocaleString();
      estimatedSizeEl.textContent = `約 ${estimatedSizeMB.toLocaleString()} MB`;
      
      // 詳細なキャッシュ状況を非同期で取得
      currentCacheInfoEl.textContent = '確認中...';
      startBtn.disabled = true;
      startBtn.textContent = '確認中...';
      
      checkCacheStatus().then(cacheStatus => {
        if (cacheStatus.cached === cacheStatus.total && cacheStatus.total > 0) {
          // 全てキャッシュ済み
          currentCacheInfoEl.innerHTML = `✅ <strong>全画像キャッシュ済み</strong> (${cacheStatus.cached}/${cacheStatus.total}枚)`;
          startBtn.disabled = true;
          startBtn.textContent = '📥 ダウンロード済み';
          startBtn.style.background = '#28a745';
        } else if (cacheStatus.cached > 0) {
          // 一部キャッシュ済み
          currentCacheInfoEl.innerHTML = `⚠️ <strong>一部キャッシュ済み</strong> (${cacheStatus.cached}/${cacheStatus.total}枚)<br>未キャッシュ: ${cacheStatus.uncached}枚`;
          startBtn.disabled = false;
          startBtn.textContent = `📥 残り${cacheStatus.uncached}枚をダウンロード`;
          startBtn.style.background = '#ffc107';
          startBtn.style.color = '#212529';
        } else {
          // キャッシュなし
          currentCacheInfoEl.innerHTML = `❌ <strong>キャッシュなし</strong> (0/${cacheStatus.total}枚)`;
          startBtn.disabled = false;
          startBtn.textContent = '📥 ダウンロード開始';
          startBtn.style.background = '#007bff';
          startBtn.style.color = 'white';
        }
        
        // 推定ダウンロードサイズを未キャッシュ分のみで再計算
        if (cacheStatus.uncached > 0) {
          const uncachedSizeMB = Math.round((cacheStatus.uncached * avgSizeKB) / 1024 * 10) / 10;
          estimatedSizeEl.textContent = `約 ${uncachedSizeMB.toLocaleString()} MB (未キャッシュ分)`;
        } else if (cacheStatus.cached > 0) {
          estimatedSizeEl.textContent = `ダウンロード不要`;
        }
        
      }).catch(error => {
        currentCacheInfoEl.textContent = '❌ 情報取得失敗';
        startBtn.disabled = false;
        startBtn.textContent = '📥 ダウンロード開始';
      });
      
      modal.style.display = 'block';
    }

    // 画像ダウンロード確認ダイアログを非表示
    function hideImageDownloadDialog() {
      const modal = document.getElementById('imageDownloadModal');
      
      if (imageDownloadInProgress) {
        const confirmClose = confirm('ダウンロードが実行中です。中断しますか？');
        if (!confirmClose) return;
        
        // 中断フラグを設定
        imageDownloadInProgress = false;
      }
      
      modal.style.display = 'none';
      
      // プログレスをリセット
      resetDownloadProgress();
    }

    // カードデータから画像URLを抽出
    function extractImageUrls() {
      const imageUrls = [];
      const seenUrls = new Set();
      
      
      // カードデータがオブジェクト形式の場合、値を取得
      const cardArray = Array.isArray(cards) ? cards : Object.values(cards);
      
      for (const card of cardArray) {
        // image_url プロパティから画像URLを取得（データ構造に合わせて修正）
        const imageUrl = card.image_url || card.image;
        if (imageUrl && !seenUrls.has(imageUrl)) {
          imageUrls.push(imageUrl);
          seenUrls.add(imageUrl);
        }
      }
      
      return imageUrls;
    }

    // ダウンロード進捗をリセット
    function resetDownloadProgress() {
      const progressDiv = document.getElementById('downloadProgress');
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      const startBtn = document.getElementById('startDownloadBtn');
      const cancelBtn = document.getElementById('cancelDownloadBtn');
      
      progressDiv.style.display = 'none';
      progressBar.style.width = '0%';
      progressText.textContent = '準備中...';
      startBtn.disabled = false;
      startBtn.textContent = '📥 ダウンロード開始';
      cancelBtn.textContent = 'キャンセル';
    }

    // 画像一括ダウンロード開始（card_list.jsのロジックを移植）
    async function startImageDownload() {
      if (imageDownloadInProgress) return;
      
      imageDownloadInProgress = true;
      
      const progressDiv = document.getElementById('downloadProgress');
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      const startBtn = document.getElementById('startDownloadBtn');
      const cancelBtn = document.getElementById('cancelDownloadBtn');
      
      // UIを更新
      progressDiv.style.display = 'block';
      startBtn.disabled = true;
      startBtn.textContent = 'ダウンロード中...';
      cancelBtn.textContent = '中断';
      
      try {
        // キャッシュ状況をチェックして、未キャッシュの画像のみを対象にする
        progressText.textContent = 'キャッシュ状況を確認中...';
        const cacheStatus = await checkCacheStatus();
        
        if (cacheStatus.uncached === 0) {
          // 全てキャッシュ済み
          progressText.textContent = '✅ 全ての画像は既にキャッシュされています';
          startBtn.textContent = '✅ 完了';
          cancelBtn.textContent = '閉じる';
          alert('全ての画像は既にキャッシュされているため、ダウンロードの必要はありません。');
          return;
        }
        
        const imageUrls = cacheStatus.uncachedUrls; // 未キャッシュの画像のみ
        const totalCount = imageUrls.length;
        let successCount = 0;
        let failureCount = 0;
        
        
        progressText.textContent = `未キャッシュ画像を事前読み込み中... (${totalCount}枚)`;
        
        // バッチサイズ（同時ダウンロード数）
        const batchSize = 3; // バッチサイズを小さくして安定性向上
        
        for (let i = 0; i < imageUrls.length; i += batchSize) {
          if (!imageDownloadInProgress) {
            break; // 中断された場合
          }
          
          const batch = imageUrls.slice(i, i + batchSize);
          
          const batchPromises = batch.map(async (url) => {
            return new Promise(async (resolve) => {
              try {
                const timeout = setTimeout(() => {
                  resolve({ success: false, url, error: 'Timeout' });
                }, 15000); // 15秒タイムアウト
                
                // Service Workerがキャッシュに保存するようにfetchを実行
                const response = await fetch(url);
                
                clearTimeout(timeout);
                
                // レスポンス状態をチェック
                if (response.ok || response.type === 'opaque') {
                  resolve({ success: true, url, cached: true });
                } else {
                  resolve({ success: false, url, error: `HTTP ${response.status}` });
                }
                
              } catch (error) {
                
                // fetch失敗の場合、Imageオブジェクトでフォールバック
                try {
                  const img = new Image();
                  const imgTimeout = setTimeout(() => {
                    resolve({ success: false, url, error: 'Image load timeout' });
                  }, 10000);
                  
                  img.onload = () => {
                    clearTimeout(imgTimeout);
                    resolve({ success: true, url, cached: false });
                  };
                  
                  img.onerror = () => {
                    clearTimeout(imgTimeout);
                    resolve({ success: false, url, error: 'Image load failed' });
                  };
                  
                  img.src = url;
                } catch (imgError) {
                  resolve({ success: false, url, error: `Both fetch and image failed: ${error.message}` });
                }
              }
            });
          });
          
          // バッチ実行
          const batchResults = await Promise.all(batchPromises);
          
          // 結果を集計
          batchResults.forEach(result => {
            if (result.success) {
              successCount++;
            } else {
              failureCount++;
            }
          });
          
          // プログレス更新
          const progress = Math.round((successCount + failureCount) / totalCount * 100);
          progressBar.style.width = `${progress}%`;
          
          // 全体の進捗情報を表示（既キャッシュ + 新規ダウンロード）
          const totalCachedNow = cacheStatus.cached + successCount;
          const grandTotal = cacheStatus.total;
          progressText.textContent = `${successCount + failureCount} / ${totalCount} 完了 (成功: ${successCount}, 失敗: ${failureCount})\n全体: ${totalCachedNow}/${grandTotal}枚がキャッシュ済み`;
          
          // 少し待機（サーバー負荷軽減）
          await new Promise(resolve => setTimeout(resolve, 300));
        }
        
        if (imageDownloadInProgress) {
          // 完了メッセージ
          const totalCachedFinal = cacheStatus.cached + successCount;
          const grandTotal = cacheStatus.total;
          
          if (failureCount === 0) {
            progressText.textContent = `✅ 新規画像のダウンロードが完了しました！ (${successCount}枚)\n全体: ${totalCachedFinal}/${grandTotal}枚がキャッシュ済み`;
            alert(`画像一括ダウンロードが完了しました！\n\n新規ダウンロード: ${successCount}枚\n既存キャッシュ: ${cacheStatus.cached}枚\n合計: ${totalCachedFinal}/${grandTotal}枚\n\nオフラインでも画像が表示されるようになりました。`);
          } else {
            progressText.textContent = `⚠️ ダウンロード完了 (成功: ${successCount}枚, 失敗: ${failureCount}枚)\n全体: ${totalCachedFinal}/${grandTotal}枚がキャッシュ済み`;
            alert(`画像一括ダウンロードが完了しました。\n\n新規成功: ${successCount}枚\n失敗: ${failureCount}枚\n既存キャッシュ: ${cacheStatus.cached}枚\n\n成功した画像はオフラインでも表示されます。`);
          }
          
          startBtn.textContent = '✅ 完了';
          cancelBtn.textContent = '閉じる';
        } else {
          // 中断された場合
          const totalCachedFinal = cacheStatus.cached + successCount;
          const grandTotal = cacheStatus.total;
          progressText.textContent = `❌ ダウンロードが中断されました (成功: ${successCount}枚, 失敗: ${failureCount}枚)\n全体: ${totalCachedFinal}/${grandTotal}枚がキャッシュ済み`;
          startBtn.textContent = '中断済み';
          cancelBtn.textContent = '閉じる';
        }
        
      } catch (error) {
        progressText.textContent = '❌ ダウンロードエラーが発生しました';
        alert(`画像ダウンロード中にエラーが発生しました：${error.message}`);
        
        startBtn.textContent = '❌ エラー';
        cancelBtn.textContent = '閉じる';
      } finally {
        imageDownloadInProgress = false;
        startBtn.disabled = false;
      }
    }

    // 画像キャッシュを削除
    async function clearImageCache() {
      if (!confirm('画像キャッシュを削除しますか？\n\n削除後は再度ダウンロードが必要になります。')) {
        return;
      }

      const clearBtn = document.getElementById('clearCacheBtn');
      const originalText = clearBtn.textContent;
      
      try {
        clearBtn.disabled = true;
        clearBtn.textContent = '削除中...';
        
        // すべてのキャッシュを取得
        const cacheNames = await caches.keys();
        
        let deletedCount = 0;
        let totalSize = 0;
        
        // 画像関連のキャッシュエントリを削除
        for (const cacheName of cacheNames) {
          const cache = await caches.open(cacheName);
          const requests = await cache.keys();
          
          for (const request of requests) {
            // 画像URLまたはhololive-official-cardgame.comのリクエストを削除
            if (request.url.includes('hololive-official-cardgame.com') ||
                request.url.includes('.jpg') ||
                request.url.includes('.png') ||
                request.url.includes('.jpeg') ||
                request.url.includes('.webp')) {
              
              const response = await cache.match(request);
              if (response) {
                const clonedResponse = response.clone();
                try {
                  // レスポンスサイズを推定（可能であれば）
                  const blob = await clonedResponse.blob();
                  totalSize += blob.size;
                } catch (e) {
                  // サイズ取得失敗は無視
                }
              }
              
              await cache.delete(request);
              deletedCount++;
            }
          }
        }
        
        // サイズを人間が読める形式に変換
        const sizeText = totalSize > 0 ? 
          `約 ${(totalSize / (1024 * 1024)).toFixed(1)} MB` : 
          '不明';
        
        clearBtn.textContent = '✅ 削除完了';
        
        alert(`画像キャッシュを削除しました！\n\n削除した画像数: ${deletedCount}枚\n削除したサイズ: ${sizeText}\n\n次回表示時にはネットワークから画像を読み込みます。`);
        
        // UIをリセット
        setTimeout(() => {
          clearBtn.textContent = originalText;
          clearBtn.disabled = false;
        }, 2000);
        
      } catch (error) {
        clearBtn.textContent = '❌ エラー';
        alert(`キャッシュ削除中にエラーが発生しました：${error.message}`);
        
        setTimeout(() => {
          clearBtn.textContent = originalText;
          clearBtn.disabled = false;
        }, 2000);
      }
    }

    // キャッシュ状況を詳細チェック
    async function checkCacheStatus() {
      try {
        const imageUrls = extractImageUrls();
        const cacheNames = await caches.keys();
        
        let cachedUrls = new Set();
        let uncachedUrls = [];
        
        // すべてのキャッシュをチェック
        for (const cacheName of cacheNames) {
          const cache = await caches.open(cacheName);
          
          for (const url of imageUrls) {
            const response = await cache.match(url);
            if (response) {
              cachedUrls.add(url);
            }
          }
        }
        
        // キャッシュされていないURLを特定
        for (const url of imageUrls) {
          if (!cachedUrls.has(url)) {
            uncachedUrls.push(url);
          }
        }
        
        return {
          total: imageUrls.length,
          cached: cachedUrls.size,
          uncached: uncachedUrls.length,
          cachedUrls: Array.from(cachedUrls),
          uncachedUrls: uncachedUrls
        };
        
      } catch (error) {
        return {
          total: 0,
          cached: 0,
          uncached: 0,
          cachedUrls: [],
          uncachedUrls: []
        };
      }
    }

    // 画像一括DL機能 - カード一覧ページと連携
    let imageDownloadInProgress = false;
    let cards = []; // カードデータをグローバルに保持

    // カードデータを動的に読み込み
    async function loadCardData() {
      try {
        const response = await fetch('json_file/card_data.json');
        if (!response.ok) throw new Error('カードデータの読み込みに失敗しました');
        const cardData = await response.json();
        
        // オブジェクトの場合は配列に変換
        cards = Array.isArray(cardData) ? cardData : Object.values(cardData);
        return cards;
      } catch (error) {
        alert('カードデータの読み込みに失敗しました。ネットワーク接続を確認してください。');
        return [];
      }
    }

    // 読み取り専用モードの切り替え
    function toggleReadOnlyMode() {
      const toggle = document.getElementById('readOnlyToggle');
      const isEnabled = toggle.checked;

      // utils.js の readOnlyMode オブジェクトを使用
      if (window.readOnlyMode) {
        window.readOnlyMode.setEnabled(isEnabled);
      } else {
        localStorage.setItem('readOnlyMode', isEnabled ? 'true' : 'false');
      }

      updateReadOnlyUI(isEnabled);
    }

    // 読み取り専用モードのUI更新
    function updateReadOnlyUI(isEnabled) {
      const label = document.getElementById('readOnlyLabel');
      const description = document.getElementById('readOnlyDescription');

      if (isEnabled) {
        label.textContent = '🔒 読み取り専用';
        label.style.color = '#dc3545';
        description.textContent = 'カード所持数・デッキ・バインダーの編集が無効になっています';
        description.style.color = '#dc3545';
      } else {
        label.textContent = '🔓 編集可能';
        label.style.color = '#28a745';
        description.textContent = '有効にすると、カード所持数・デッキ・バインダーの編集ができなくなります';
        description.style.color = '#888';
      }
    }

    // ページ読み込み時に読み取り専用モードの状態を復元
    function initializeReadOnlyMode() {
      const isEnabled = localStorage.getItem('readOnlyMode') === 'true';
      const toggle = document.getElementById('readOnlyToggle');

      if (toggle) {
        toggle.checked = isEnabled;
        updateReadOnlyUI(isEnabled);
      }
    }

    // DOMContentLoaded で初期化
    document.addEventListener('DOMContentLoaded', function() {
      initializeReadOnlyMode();
      initializeViewingOtherStorageUI();
    });

    // ===== 他人のストレイジ閲覧機能 =====

    /**
     * 他人のストレイジ閲覧UIの初期化
     */
    function initializeViewingOtherStorageUI() {
      // 閲覧中かどうかをチェック
      if (window.storageProvider && window.storageProvider.isViewing()) {
        updateViewingUI(true);
      }

      // イベントリスナーを設定
      window.addEventListener('storageProviderChange', function(e) {
        updateViewingUI(e.detail.isViewing);
      });

      // クエリストリングからviewFileIdをチェック
      checkViewFileIdQueryString();
    }

    /**
     * クエリストリングのviewFileIdをチェックして自動的に閲覧モードを開始
     */
    async function checkViewFileIdQueryString() {
      const urlParams = new URLSearchParams(window.location.search);
      const viewFileId = urlParams.get('viewFileId');

      if (!viewFileId) return;

      // すでに閲覧中の場合はスキップ
      if (window.storageProvider && window.storageProvider.isViewing()) {
        console.log('すでに閲覧中のため、クエリストリングからの開始をスキップ');
        return;
      }

      // URLからクエリストリングを削除（履歴を置換）
      const cleanUrl = window.location.pathname + window.location.hash;
      window.history.replaceState({}, document.title, cleanUrl);

      // 読み込み中の表示
      const startBtn = document.getElementById('startViewingBtn');
      if (startBtn) {
        startBtn.disabled = true;
        startBtn.textContent = '📥 読み込み中...';
      }

      try {
        // Googleドライブからファイルを読み込み
        const result = await window.googleDriveSync.loadFromOtherStorage(viewFileId);

        if (!result.success) {
          alert('クエリストリングで指定されたファイルの読み込みに失敗しました: ' + result.message);
          return;
        }

        // 閲覧モードを開始
        if (window.storageProvider.startViewing(result.data)) {
          window.showToast('クエリストリングからストレイジの閲覧を開始しました', 'success');
          updateViewingUI(true);
        } else {
          alert('閲覧モードの開始に失敗しました');
        }

      } catch (error) {
        console.error('クエリストリングからの閲覧開始エラー:', error);
        alert('予期しないエラーが発生しました: ' + error.message);
      } finally {
        if (startBtn) {
          startBtn.disabled = false;
          startBtn.textContent = '🚀 開始';
        }
      }
    }

    /**
     * 他人のストレイジの閲覧を開始
     * Googleにログインしていなくても公開ファイルなら閲覧可能
     */
    async function startViewingOtherStorage() {
      const fileIdInput = document.getElementById('otherStorageFileId');
      const startBtn = document.getElementById('startViewingBtn');

      if (!fileIdInput || !startBtn) return;

      const fileId = fileIdInput.value.trim();

      if (!fileId) {
        alert('ファイルIDを入力してください');
        fileIdInput.focus();
        return;
      }

      // ボタンを無効化
      startBtn.disabled = true;
      startBtn.textContent = '📥 読み込み中...';

      try {
        // Googleドライブからファイルを読み込み（ログイン不要）
        const result = await window.googleDriveSync.loadFromOtherStorage(fileId);

        if (!result.success) {
          alert('エラー: ' + result.message);
          startBtn.disabled = false;
          startBtn.textContent = '🚀 開始';
          return;
        }

        // 閲覧モードを開始
        if (window.storageProvider.startViewing(result.data)) {
          window.showToast('他の人のストレイジの閲覧を開始しました', 'success');

          // UIを更新
          updateViewingUI(true);

          // 入力欄をクリア
          fileIdInput.value = '';
        } else {
          alert('閲覧モードの開始に失敗しました');
        }

      } catch (error) {
        console.error('閲覧開始エラー:', error);
        alert('予期しないエラーが発生しました: ' + error.message);
      } finally {
        startBtn.disabled = false;
        startBtn.textContent = '🚀 開始';
      }
    }

    /**
     * 他人のストレイジの閲覧を終了
     */
    function stopViewingOtherStorage() {
      if (confirm('閲覧を終了して自分のストレイジに戻りますか？\n\nページがリロードされます。')) {
        if (window.storageProvider) {
          window.storageProvider.stopViewing();
        }
      }
    }

    /**
     * 閲覧UIの表示/非表示を切り替え
     * @param {boolean} isViewing - 閲覧中かどうか
     */
    function updateViewingUI(isViewing) {
      const readOnlyModeSection = document.getElementById('readOnlyModeSection');
      const viewingSection = document.getElementById('viewingOtherStorageSection');
      const viewOtherSection = document.getElementById('viewOtherStorageSection');

      if (isViewing) {
        // 閲覧中: 読み取り専用トグルを非表示、閲覧中セクションを表示、入力セクションを非表示
        if (readOnlyModeSection) readOnlyModeSection.style.display = 'none';
        if (viewingSection) viewingSection.style.display = 'block';
        if (viewOtherSection) viewOtherSection.style.display = 'none';
      } else {
        // 通常: 読み取り専用トグルを表示、閲覧中セクションを非表示、入力セクションを表示
        if (readOnlyModeSection) readOnlyModeSection.style.display = 'block';
        if (viewingSection) viewingSection.style.display = 'none';
        if (viewOtherSection) viewOtherSection.style.display = 'block';
      }
    }

    // ===== ドライブエクスポート機能 =====
    let exportInProgress = false;

    // ドライブエクスポートダイアログを表示
    async function showDriveExportDialog() {
      const modal = document.getElementById('driveExportModal');
      const loginPrompt = document.getElementById('exportLoginPrompt');
      const existsPrompt = document.getElementById('exportExistsPrompt');
      const exportProgress = document.getElementById('exportProgress');
      const exportResult = document.getElementById('exportResult');
      const startBtn = document.getElementById('exportStartBtn');
      const overwriteBtn = document.getElementById('exportOverwriteBtn');
      const exportFileName = document.getElementById('exportFileName');

      // 状態をリセット
      loginPrompt.style.display = 'none';
      existsPrompt.style.display = 'none';
      exportProgress.style.display = 'none';
      exportResult.style.display = 'none';
      startBtn.style.display = 'inline-block';
      startBtn.disabled = false;
      startBtn.textContent = '☁️ エクスポート';
      overwriteBtn.style.display = 'none';

      // ファイル名を表示
      if (window.googleDriveSync) {
        exportFileName.textContent = window.googleDriveSync.getExportFileName();
      }

      // ログイン状態をチェック
      if (!window.googleDriveSync || !window.googleDriveSync.getSignedIn()) {
        loginPrompt.style.display = 'block';
        startBtn.disabled = true;
        startBtn.textContent = 'ログインしてください';
      }

      modal.style.display = 'block';
    }

    // ドライブエクスポートダイアログを非表示
    function hideDriveExportDialog() {
      const modal = document.getElementById('driveExportModal');
      if (exportInProgress) {
        if (!confirm('エクスポートを中断しますか？')) {
          return;
        }
        exportInProgress = false;
      }
      modal.style.display = 'none';
    }

    // エクスポートを実行
    async function executeExport(overwrite) {
      if (exportInProgress) return;

      if (!window.googleDriveSync || !window.googleDriveSync.getSignedIn()) {
        alert('Googleにログインしてください');
        return;
      }

      exportInProgress = true;

      const loginPrompt = document.getElementById('exportLoginPrompt');
      const existsPrompt = document.getElementById('exportExistsPrompt');
      const exportProgress = document.getElementById('exportProgress');
      const exportProgressBar = document.getElementById('exportProgressBar');
      const exportProgressText = document.getElementById('exportProgressText');
      const exportResult = document.getElementById('exportResult');
      const startBtn = document.getElementById('exportStartBtn');
      const overwriteBtn = document.getElementById('exportOverwriteBtn');
      const cancelBtn = document.getElementById('exportCancelBtn');

      // UIを更新
      loginPrompt.style.display = 'none';
      existsPrompt.style.display = 'none';
      exportProgress.style.display = 'block';
      exportResult.style.display = 'none';
      startBtn.disabled = true;
      overwriteBtn.style.display = 'none';
      cancelBtn.textContent = '中断';

      try {
        // プログレスを更新
        exportProgressBar.style.width = '30%';
        exportProgressText.textContent = 'データを収集中...';

        await new Promise(resolve => setTimeout(resolve, 300));

        exportProgressBar.style.width = '60%';
        exportProgressText.textContent = 'Googleドライブにアップロード中...';

        // エクスポート実行
        const result = await window.googleDriveSync.exportToFile(overwrite);

        if (!result.success) {
          if (result.message === 'exists') {
            // ファイルが既に存在する場合
            exportProgress.style.display = 'none';
            existsPrompt.style.display = 'block';

            const existingFileInfo = document.getElementById('existingFileInfo');
            const modifiedDate = new Date(result.existingFile.modifiedTime);
            existingFileInfo.textContent = `最終更新: ${modifiedDate.toLocaleString('ja-JP')}`;

            startBtn.style.display = 'none';
            overwriteBtn.style.display = 'inline-block';
            cancelBtn.textContent = 'キャンセル';
            exportInProgress = false;
            return;
          } else {
            throw new Error(result.message);
          }
        }

        // 成功
        exportProgressBar.style.width = '80%';
        exportProgressText.textContent = '共有設定を処理中...';

        // チェックボックスの状態を取得
        const publicCheckbox = document.getElementById('exportPublicCheckbox');
        const makePublic = publicCheckbox && publicCheckbox.checked;

        // 共有設定を処理
        let shareUrl = null;
        let sharingMessage = '';

        if (makePublic) {
          // 公開設定にする
          const shareResult = await window.googleDriveSync.makeFilePublic(result.fileId);
          if (shareResult.success) {
            shareUrl = window.googleDriveSync.generateShareUrl(result.fileId);
            if (shareResult.message === 'made_public') {
              sharingMessage = '🔗 公開設定に変更しました';
            } else {
              sharingMessage = '🔗 既に公開設定です';
            }
          } else {
            sharingMessage = '⚠️ 公開設定に失敗: ' + shareResult.message;
          }
        } else {
          // 非公開設定にする（既に公開の場合のみ）
          const privateResult = await window.googleDriveSync.makeFilePrivate(result.fileId);
          if (privateResult.success) {
            if (privateResult.message === 'made_private') {
              sharingMessage = '🔒 非公開設定に変更しました';
            }
            // already_private の場合はメッセージなし
          } else {
            sharingMessage = '⚠️ 非公開設定に失敗: ' + privateResult.message;
          }
        }

        exportProgressBar.style.width = '100%';
        exportProgressText.textContent = '完了！';

        await new Promise(resolve => setTimeout(resolve, 500));

        exportProgress.style.display = 'none';
        exportResult.style.display = 'block';
        exportResult.style.background = '#d4edda';
        exportResult.style.border = '1px solid #c3e6cb';
        exportResult.style.color = '#155724';

        const actionText = result.message === 'updated' ? '上書き保存' : '新規作成';
        let resultHtml = `
          <strong>✅ エクスポート${actionText === '上書き保存' ? '（上書き）' : ''}完了！</strong><br>
          <span style="font-size:0.85em;">
            ファイル名: ${result.fileName}<br>
            カード所持数: ${result.stats.cardCount}件<br>
            デッキ: ${result.stats.deckCount}件<br>
            バインダー: ${result.stats.binderCount}件
          </span>
        `;

        if (sharingMessage) {
          resultHtml += `<br><span style="font-size:0.85em;">${sharingMessage}</span>`;
        }

        if (shareUrl) {
          resultHtml += `
            <div style="margin-top:10px; padding:10px; background:#e8f4fd; border:1px solid #b3d7f5; border-radius:5px; text-align:left;">
              <strong style="color:#0066cc;">📤 共有URL:</strong><br>
              <div style="display:flex; gap:5px; margin-top:5px;">
                <input type="text" id="shareUrlInput" value="${shareUrl}" readonly
                  style="flex:1; padding:8px; border:1px solid #ccc; border-radius:4px; font-size:0.85em; background:#fff;">
                <button onclick="copyShareUrl()" style="padding:8px 12px; background:#4285f4; color:white; border:none; border-radius:4px; cursor:pointer; font-size:0.85em; white-space:nowrap;">
                  📋 コピー
                </button>
              </div>
            </div>
          `;
        }

        exportResult.innerHTML = resultHtml;

        startBtn.style.display = 'none';
        overwriteBtn.style.display = 'none';
        cancelBtn.textContent = '閉じる';

      } catch (error) {
        console.error('エクスポートエラー:', error);

        exportProgress.style.display = 'none';
        exportResult.style.display = 'block';
        exportResult.style.background = '#f8d7da';
        exportResult.style.border = '1px solid #f5c6cb';
        exportResult.style.color = '#721c24';
        exportResult.innerHTML = `<strong>❌ エクスポート失敗</strong><br>${error.message || '不明なエラー'}`;

        startBtn.disabled = false;
        cancelBtn.textContent = '閉じる';
      } finally {
        exportInProgress = false;
      }
    }

    // 共有URLをコピー
    function copyShareUrl() {
      const input = document.getElementById('shareUrlInput');
      if (!input) return;

      input.select();
      input.setSelectionRange(0, 99999); // モバイル対応

      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(input.value).then(() => {
            showCopySuccess();
          }).catch(() => {
            // フォールバック
            document.execCommand('copy');
            showCopySuccess();
          });
        } else {
          document.execCommand('copy');
          showCopySuccess();
        }
      } catch (err) {
        console.error('コピーに失敗:', err);
        alert('コピーに失敗しました。手動でコピーしてください。');
      }
    }

    function showCopySuccess() {
      const btn = document.querySelector('#exportResult button');
      if (btn) {
        const originalText = btn.textContent;
        btn.textContent = '✅ コピーしました';
        btn.style.background = '#28a745';
        setTimeout(() => {
          btn.textContent = originalText;
          btn.style.background = '#4285f4';
        }, 2000);
      }
    }

    // Googleログイン状態の変更を監視
    window.addEventListener('googleSignInChange', function(e) {
      const driveExportBtn = document.getElementById('driveExportBtn');
      const loginPrompt = document.getElementById('exportLoginPrompt');
      const startBtn = document.getElementById('exportStartBtn');

      if (e.detail.signedIn) {
        // ログインした
        if (driveExportBtn) {
          driveExportBtn.style.opacity = '1';
        }
        if (loginPrompt) {
          loginPrompt.style.display = 'none';
        }
        if (startBtn) {
          startBtn.disabled = false;
          startBtn.textContent = '☁️ エクスポート';
        }
      } else {
        // ログアウトした
        if (loginPrompt && loginPrompt.closest('#driveExportModal').style.display !== 'none') {
          loginPrompt.style.display = 'block';
        }
        if (startBtn) {
          startBtn.disabled = true;
          startBtn.textContent = 'ログインしてください';
        }
      }
    });

    // 全キャッシュ削除機能
    async function clearAllCache() {
      if (!confirm('全てのキャッシュを削除しますか？\n\n・画像キャッシュ\n・アプリケーションキャッシュ\n・ローカルストレージ\n\n削除後は全データを再ダウンロードします。')) {
        return;
      }

      const clearBtn = document.getElementById('clearCacheBtn');
      const originalText = clearBtn.textContent;
      
      try {
        clearBtn.disabled = true;
        clearBtn.textContent = '削除中...';
        
        let deletedCaches = 0;
        let deletedStorage = 0;
        
        // 1. Service Worker キャッシュを削除
        const cacheNames = await caches.keys();
        for (const cacheName of cacheNames) {
          await caches.delete(cacheName);
          deletedCaches++;
        }
        
        // 2. localStorage を削除（バインダー関連は保護）
        const localStorageKeys = Object.keys(localStorage);
        const appKeys = localStorageKeys.filter(key => 
          (key.includes('card') || key.includes('deck') || 
          key.includes('Data') || key.includes('darkMode') || key.includes('version') ||
          key.includes('filter') || key.includes('view') || key.includes('owned') ||
          key.startsWith('count_')) &&
          // バインダー関連のキーは除外
          !key.includes('binder') && !key.includes('Binder')
        );
        
        appKeys.forEach(key => {
          localStorage.removeItem(key);
          deletedStorage++;
        });
        
        clearBtn.textContent = '✅ 削除完了';
        
        alert(`全キャッシュを削除しました！\n\n削除したキャッシュ: ${deletedCaches}個\n削除したローカルデータ: ${deletedStorage}個\n\n次回アクセス時に全データを再ダウンロードします。`);
        
        // UIをリセット
        setTimeout(() => {
          clearBtn.textContent = originalText;
          clearBtn.disabled = false;
        }, 2000);
        
      } catch (error) {
        clearBtn.textContent = '❌ エラー';
        alert(`キャッシュ削除中にエラーが発生しました：${error.message}`);
        
        setTimeout(() => {
          clearBtn.textContent = originalText;
          clearBtn.disabled = false;
        }, 2000);
      }
    }
  </script>
  <!-- オフライン状態管理 -->
  <script src="js/offline-utils.js"></script>
  <!-- 共通ユーティリティ -->
  <script src="js/utils.js"></script>
  <!-- Google Drive同期 -->
  <script src="config/google-client-id.js"></script>
  <script src="js/google-drive-sync.js"></script>
  <script>
    // Google Drive同期UIを初期化
    document.addEventListener('DOMContentLoaded', function() {
      // コンテナのヘッダー部分にGoogle Drive UIを追加
      const container = document.querySelector('.container');
      if (container) {
        // タイトルの直後にUIを挿入するためのヘッダー要素を作成
        const h1 = container.querySelector('h1');
        if (h1) {
          const driveHeader = document.createElement('div');
          driveHeader.className = 'google-drive-header';
          driveHeader.style.cssText = 'display: flex; justify-content: center; align-items: center; margin-bottom: 20px;';
          h1.parentNode.insertBefore(driveHeader, h1.nextSibling);
          window.initializeGoogleDriveSync('.google-drive-header');
        }
      }
    });
  </script>
</body>
</html>
